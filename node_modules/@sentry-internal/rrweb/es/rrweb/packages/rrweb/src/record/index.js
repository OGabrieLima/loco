import {
    createMirror,
    snapshot
} from '../../../rrweb-snapshot/es/rrweb-snapshot.js';
import {
    initObservers,
    mutationBuffers
} from './observer.js';
import {
    polyfill,
    on,
    nowTimestamp,
    getWindowWidth,
    getWindowHeight,
    getWindowScroll,
    isSerializedIframe,
    isSerializedStylesheet,
    hasShadowRoot
} from '../utils.js';
import {
    EventType,
    IncrementalSource
} from '../../../types/dist/rrweb-types.js';
import {
    IframeManagerNoop,
    IframeManager
} from './iframe-manager.js';
import {
    ShadowDomManagerNoop,
    ShadowDomManager
} from './shadow-dom-manager.js';
import {
    CanvasManagerNoop
} from './observers/canvas/canvas-manager.js';
export {
    CanvasManager
}
from './observers/canvas/canvas-manager.js';
import {
    StylesheetManager
} from './stylesheet-manager.js';
import ProcessedNodeManager from './processed-node-manager.js';
import {
    callbackWrapper,
    unregisterErrorHandler,
    registerErrorHandler
} from './error-handler.js';

let wrappedEmit;
let _wrappedEmit;
let _takeFullSnapshot;
try {
    if (Array.from([1], (x) => x * 2)[0] !== 2) {
        const cleanFrame = document.createElement('iframe');
        document.body.appendChild(cleanFrame);
        Array.from = cleanFrame.contentWindow ? .Array.from || Array.from;
        document.body.removeChild(cleanFrame);
    }
} catch (err) {
    console.debug('Unable to override Array.from', err);
}
const mirror = createMirror();

function record(options = {}) {
    const {
        emit,
        checkoutEveryNms,
        checkoutEveryNth,
        blockClass = 'rr-block',
        blockSelector = null,
        unblockSelector = null,
        ignoreClass = 'rr-ignore',
        ignoreSelector = null,
        maskAllText = false,
        maskTextClass = 'rr-mask',
        unmaskTextClass = null,
        maskTextSelector = null,
        unmaskTextSelector = null,
        inlineStylesheet = true,
        maskAllInputs,
        maskInputOptions: _maskInputOptions,
        slimDOMOptions: _slimDOMOptions,
        maskAttributeFn,
        maskInputFn,
        maskTextFn,
        maxCanvasSize = null,
        packFn,
        sampling = {},
        dataURLOptions = {},
        mousemoveWait,
        recordDOM = true,
        recordCanvas = false,
        recordCrossOriginIframes = false,
        recordAfter = options.recordAfter === 'DOMContentLoaded' ?
        options.recordAfter :
            'load',
        userTriggeredOnInput = false,
        collectFonts = false,
        inlineImages = false,
        plugins,
        keepIframeSrcFn = () => false,
        ignoreCSSAttributes = new Set([]),
        errorHandler,
        onMutation,
        getCanvasManager,
    } = options;
    registerErrorHandler(errorHandler);
    const inEmittingFrame = recordCrossOriginIframes ?
        window.parent === window :
        true;
    let passEmitsToParent = false;
    if (!inEmittingFrame) {
        try {
            if (window.parent.document) {
                passEmitsToParent = false;
            }
        } catch (e) {
            passEmitsToParent = true;
        }
    }
    if (inEmittingFrame && !emit) {
        throw new Error('emit function is required');
    }
    if (!inEmittingFrame && !passEmitsToParent) {
        return () => {};
    }
    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {
        sampling.mousemove = mousemoveWait;
    }
    mirror.reset();
    const maskInputOptions = maskAllInputs === true ?
        {
            color: true,
            date: true,
            'datetime-local': true,
            email: true,
            month: true,
            number: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true,
            textarea: true,
            select: true,
            radio: true,
            checkbox: true,
        } :
        _maskInputOptions !== undefined ?
        _maskInputOptions :
        {};
    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all' ?
        {
            script: true,
            comment: true,
            headFavicon: true,
            headWhitespace: true,
            headMetaSocial: true,
            headMetaRobots: true,
            headMetaHttpEquiv: true,
            headMetaVerification: true,
            headMetaAuthorship: _slimDOMOptions === 'all',
            headMetaDescKeywords: _slimDOMOptions === 'all',
        } :
        _slimDOMOptions ?
        _slimDOMOptions :
        {};
    polyfill();
    let lastFullSnapshotEvent;
    let incrementalSnapshotCount = 0;
    const eventProcessor = (e) => {
        for (const plugin of plugins || []) {
            if (plugin.eventProcessor) {
                e = plugin.eventProcessor(e);
            }
        }
        if (packFn &&
            !passEmitsToParent) {
            e = packFn(e);
        }
        return e;
    };
    wrappedEmit = (r, isCheckout) => {
        const e = r;
        e.timestamp = nowTimestamp();
        if (mutationBuffers[0] ? .isFrozen() &&
            e.type !== EventType.FullSnapshot &&
            !(e.type === EventType.IncrementalSnapshot &&
                e.data.source === IncrementalSource.Mutation)) {
            mutationBuffers.forEach((buf) => buf.unfreeze());
        }
        if (inEmittingFrame) {
            emit ? .(eventProcessor(e), isCheckout);
        } else if (passEmitsToParent) {
            const message = {
                type: 'rrweb',
                event: eventProcessor(e),
                origin: window.location.origin,
                isCheckout,
            };
            window.parent.postMessage(message, '*');
        }
        if (e.type === EventType.FullSnapshot) {
            lastFullSnapshotEvent = e;
            incrementalSnapshotCount = 0;
        } else if (e.type === EventType.IncrementalSnapshot) {
            if (e.data.source === IncrementalSource.Mutation &&
                e.data.isAttachIframe) {
                return;
            }
            incrementalSnapshotCount++;
            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
            const exceedTime = checkoutEveryNms &&
                lastFullSnapshotEvent &&
                e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
            if (exceedCount || exceedTime) {
                takeFullSnapshot(true);
            }
        }
    };
    _wrappedEmit = wrappedEmit;
    const wrappedMutationEmit = (m) => {
        wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
                source: IncrementalSource.Mutation,
                ...m,
            },
        });
    };
    const wrappedScrollEmit = (p) => wrappedEmit({
        type: EventType.IncrementalSnapshot,
        data: {
            source: IncrementalSource.Scroll,
            ...p,
        },
    });
    const wrappedCanvasMutationEmit = (p) => wrappedEmit({
        type: EventType.IncrementalSnapshot,
        data: {
            source: IncrementalSource.CanvasMutation,
            ...p,
        },
    });
    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit({
        type: EventType.IncrementalSnapshot,
        data: {
            source: IncrementalSource.AdoptedStyleSheet,
            ...a,
        },
    });
    const stylesheetManager = new StylesheetManager({
        mutationCb: wrappedMutationEmit,
        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit,
    });
    const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === 'boolean' && __RRWEB_EXCLUDE_IFRAME__ ?
        new IframeManagerNoop() :
        new IframeManager({
            mirror,
            mutationCb: wrappedMutationEmit,
            stylesheetManager: stylesheetManager,
            recordCrossOriginIframes,
            wrappedEmit,
        });
    for (const plugin of plugins || []) {
        if (plugin.getMirror)
            plugin.getMirror({
                nodeMirror: mirror,
                crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
                crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror,
            });
    }
    const processedNodeManager = new ProcessedNodeManager();
    const canvasManager = _getCanvasManager(getCanvasManager, {
        mirror,
        win: window,
        mutationCb: (p) => wrappedEmit({
            type: EventType.IncrementalSnapshot,
            data: {
                source: IncrementalSource.CanvasMutation,
                ...p,
            },
        }),
        recordCanvas,
        blockClass,
        blockSelector,
        unblockSelector,
        maxCanvasSize,
        sampling: sampling['canvas'],
        dataURLOptions,
        errorHandler,
    });
    const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === 'boolean' &&
        __RRWEB_EXCLUDE_SHADOW_DOM__ ?
        new ShadowDomManagerNoop() :
        new ShadowDomManager({
            mutationCb: wrappedMutationEmit,
            scrollCb: wrappedScrollEmit,
            bypassOptions: {
                onMutation,
                blockClass,
                blockSelector,
                unblockSelector,
                maskAllText,
                maskTextClass,
                unmaskTextClass,
                maskTextSelector,
                unmaskTextSelector,
                inlineStylesheet,
                maskInputOptions,
                dataURLOptions,
                maskAttributeFn,
                maskTextFn,
                maskInputFn,
                recordCanvas,
                inlineImages,
                sampling,
                slimDOMOptions,
                iframeManager,
                stylesheetManager,
                canvasManager,
                keepIframeSrcFn,
                processedNodeManager,
            },
            mirror,
        });
    const takeFullSnapshot = (isCheckout = false) => {
        if (!recordDOM) {
            return;
        }
        wrappedEmit({
            type: EventType.Meta,
            data: {
                href: window.location.href,
                width: getWindowWidth(),
                height: getWindowHeight(),
            },
        }, isCheckout);
        stylesheetManager.reset();
        shadowDomManager.init();
        mutationBuffers.forEach((buf) => buf.lock());
        const node = snapshot(document, {
            mirror,
            blockClass,
            blockSelector,
            unblockSelector,
            maskAllText,
            maskTextClass,
            unmaskTextClass,
            maskTextSelector,
            unmaskTextSelector,
            inlineStylesheet,
            maskAllInputs: maskInputOptions,
            maskAttributeFn,
            maskInputFn,
            maskTextFn,
            slimDOM: slimDOMOptions,
            dataURLOptions,
            recordCanvas,
            inlineImages,
            onSerialize: (n) => {
                if (isSerializedIframe(n, mirror)) {
                    iframeManager.addIframe(n);
                }
                if (isSerializedStylesheet(n, mirror)) {
                    stylesheetManager.trackLinkElement(n);
                }
                if (hasShadowRoot(n)) {
                    shadowDomManager.addShadowRoot(n.shadowRoot, document);
                }
            },
            onIframeLoad: (iframe, childSn) => {
                iframeManager.attachIframe(iframe, childSn);
                if (iframe.contentWindow) {
                    canvasManager.addWindow(iframe.contentWindow);
                }
                shadowDomManager.observeAttachShadow(iframe);
            },
            onStylesheetLoad: (linkEl, childSn) => {
                stylesheetManager.attachLinkElement(linkEl, childSn);
            },
            keepIframeSrcFn,
        });
        if (!node) {
            return console.warn('Failed to snapshot the document');
        }
        wrappedEmit({
            type: EventType.FullSnapshot,
            data: {
                node,
                initialOffset: getWindowScroll(window),
            },
        });
        mutationBuffers.forEach((buf) => buf.unlock());
        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
            stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));
    };
    _takeFullSnapshot = takeFullSnapshot;
    try {
        const handlers = [];
        const observe = (doc) => {
            return callbackWrapper(initObservers)({
                onMutation,
                mutationCb: wrappedMutationEmit,
                mousemoveCb: (positions, source) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source,
                        positions,
                    },
                }),
                mouseInteractionCb: (d) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.MouseInteraction,
                        ...d,
                    },
                }),
                scrollCb: wrappedScrollEmit,
                viewportResizeCb: (d) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.ViewportResize,
                        ...d,
                    },
                }),
                inputCb: (v) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.Input,
                        ...v,
                    },
                }),
                mediaInteractionCb: (p) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.MediaInteraction,
                        ...p,
                    },
                }),
                styleSheetRuleCb: (r) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.StyleSheetRule,
                        ...r,
                    },
                }),
                styleDeclarationCb: (r) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.StyleDeclaration,
                        ...r,
                    },
                }),
                canvasMutationCb: wrappedCanvasMutationEmit,
                fontCb: (p) => wrappedEmit({
                    type: EventType.IncrementalSnapshot,
                    data: {
                        source: IncrementalSource.Font,
                        ...p,
                    },
                }),
                selectionCb: (p) => {
                    wrappedEmit({
                        type: EventType.IncrementalSnapshot,
                        data: {
                            source: IncrementalSource.Selection,
                            ...p,
                        },
                    });
                },
                customElementCb: (c) => {
                    wrappedEmit({
                        type: EventType.IncrementalSnapshot,
                        data: {
                            source: IncrementalSource.CustomElement,
                            ...c,
                        },
                    });
                },
                blockClass,
                ignoreClass,
                ignoreSelector,
                maskAllText,
                maskTextClass,
                unmaskTextClass,
                maskTextSelector,
                unmaskTextSelector,
                maskInputOptions,
                inlineStylesheet,
                sampling,
                recordDOM,
                recordCanvas,
                inlineImages,
                userTriggeredOnInput,
                collectFonts,
                doc,
                maskAttributeFn,
                maskInputFn,
                maskTextFn,
                keepIframeSrcFn,
                blockSelector,
                unblockSelector,
                slimDOMOptions,
                dataURLOptions,
                mirror,
                iframeManager,
                stylesheetManager,
                shadowDomManager,
                processedNodeManager,
                canvasManager,
                ignoreCSSAttributes,
                plugins: plugins ?
                    .filter((p) => p.observer) ?
                    .map((p) => ({
                        observer: p.observer,
                        options: p.options,
                        callback: (payload) => wrappedEmit({
                            type: EventType.Plugin,
                            data: {
                                plugin: p.name,
                                payload,
                            },
                        }),
                    })) || [],
            }, {});
        };
        iframeManager.addLoadListener((iframeEl) => {
            try {
                handlers.push(observe(iframeEl.contentDocument));
            } catch (error) {
                console.warn(error);
            }
        });
        const init = () => {
            takeFullSnapshot();
            handlers.push(observe(document));
        };
        if (document.readyState === 'interactive' ||
            document.readyState === 'complete') {
            init();
        } else {
            handlers.push(on('DOMContentLoaded', () => {
                wrappedEmit({
                    type: EventType.DomContentLoaded,
                    data: {},
                });
                if (recordAfter === 'DOMContentLoaded')
                    init();
            }));
            handlers.push(on('load', () => {
                wrappedEmit({
                    type: EventType.Load,
                    data: {},
                });
                if (recordAfter === 'load')
                    init();
            }, window));
        }
        return () => {
            handlers.forEach((h) => h());
            processedNodeManager.destroy();
            _takeFullSnapshot = undefined;
            unregisterErrorHandler();
        };
    } catch (error) {
        console.warn(error);
    }
}

function addCustomEvent(tag, payload) {
    if (!_wrappedEmit) {
        throw new Error('please add custom event after start recording');
    }
    wrappedEmit({
        type: EventType.Custom,
        data: {
            tag,
            payload,
        },
    });
}

function freezePage() {
    mutationBuffers.forEach((buf) => buf.freeze());
}

function takeFullSnapshot(isCheckout) {
    if (!_takeFullSnapshot) {
        throw new Error('please take full snapshot after start recording');
    }
    _takeFullSnapshot(isCheckout);
}
record.mirror = mirror;
record.takeFullSnapshot = takeFullSnapshot;

function _getCanvasManager(getCanvasManagerFn, options) {
    try {
        return getCanvasManagerFn ?
            getCanvasManagerFn(options) :
            new CanvasManagerNoop();
    } catch {
        console.warn('Unable to initialize CanvasManager');
        return new CanvasManagerNoop();
    }
}

export {
    addCustomEvent,
    record as
    default,
    freezePage,
    takeFullSnapshot
};