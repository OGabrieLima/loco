import {
    onRequestAnimationFrame,
    isBlocked
} from '../../../utils.js';
import {
    CanvasContext
} from '../../../../../types/dist/rrweb-types.js';
import initCanvas2DMutationObserver from './2d.js';
import initCanvasContextObserver from './canvas.js';
import initCanvasWebGLMutationObserver from './webgl.js';
import {
    getImageBitmapDataUrlWorkerURL as t
} from '../../../../../rrweb-worker/es/rrweb-worker/index.js';
import {
    callbackWrapper,
    registerErrorHandler
} from '../../error-handler.js';

class CanvasManagerNoop {
    reset() {}
    freeze() {}
    unfreeze() {}
    lock() {}
    unlock() {}
    snapshot() {}
    addWindow() {}
    addShadowRoot() {}
    resetShadowRoots() {}
}
class CanvasManager {
    reset() {
        this.pendingCanvasMutations.clear();
        this.restoreHandlers.forEach((handler) => {
            try {
                handler();
            } catch (e) {}
        });
        this.restoreHandlers = [];
        this.windowsSet = new WeakSet();
        this.windows = [];
        this.shadowDoms = new Set();
        this.worker ? .terminate();
        this.worker = null;
        this.snapshotInProgressMap = new Map();
    }
    freeze() {
        this.frozen = true;
    }
    unfreeze() {
        this.frozen = false;
    }
    lock() {
        this.locked = true;
    }
    unlock() {
        this.locked = false;
    }
    constructor(options) {
        this.pendingCanvasMutations = new Map();
        this.rafStamps = {
            latestId: 0,
            invokeId: null
        };
        this.shadowDoms = new Set();
        this.windowsSet = new WeakSet();
        this.windows = [];
        this.restoreHandlers = [];
        this.frozen = false;
        this.locked = false;
        this.snapshotInProgressMap = new Map();
        this.worker = null;
        this.processMutation = (target, mutation) => {
            const newFrame = this.rafStamps.invokeId &&
                this.rafStamps.latestId !== this.rafStamps.invokeId;
            if (newFrame || !this.rafStamps.invokeId)
                this.rafStamps.invokeId = this.rafStamps.latestId;
            if (!this.pendingCanvasMutations.has(target)) {
                this.pendingCanvasMutations.set(target, []);
            }
            this.pendingCanvasMutations.get(target).push(mutation);
        };
        const {
            sampling = 'all', win, blockClass, blockSelector, unblockSelector, maxCanvasSize, recordCanvas, dataURLOptions, errorHandler,
        } = options;
        this.mutationCb = options.mutationCb;
        this.mirror = options.mirror;
        this.options = options;
        if (errorHandler) {
            registerErrorHandler(errorHandler);
        }
        if ((recordCanvas && typeof sampling === 'number') ||
            options.enableManualSnapshot) {
            this.worker = this.initFPSWorker();
        }
        this.addWindow(win);
        if (options.enableManualSnapshot) {
            return;
        }
        callbackWrapper(() => {
            if (recordCanvas && sampling === 'all') {
                this.startRAFTimestamping();
                this.startPendingCanvasMutationFlusher();
            }
            if (recordCanvas && typeof sampling === 'number') {
                this.initCanvasFPSObserver(sampling, blockClass, blockSelector, unblockSelector, maxCanvasSize, {
                    dataURLOptions,
                });
            }
        })();
    }
    addWindow(win) {
        const {
            sampling = 'all', blockClass, blockSelector, unblockSelector, recordCanvas, enableManualSnapshot,
        } = this.options;
        if (this.windowsSet.has(win))
            return;
        if (enableManualSnapshot) {
            this.windowsSet.add(win);
            this.windows.push(new WeakRef(win));
            return;
        }
        callbackWrapper(() => {
            if (recordCanvas && sampling === 'all') {
                this.initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector);
            }
            if (recordCanvas && typeof sampling === 'number') {
                const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, true);
                this.restoreHandlers.push(() => {
                    canvasContextReset();
                });
            }
        })();
        this.windowsSet.add(win);
        this.windows.push(new WeakRef(win));
    }
    addShadowRoot(shadowRoot) {
        this.shadowDoms.add(new WeakRef(shadowRoot));
    }
    resetShadowRoots() {
        this.shadowDoms = new Set();
    }
    initFPSWorker() {
        const worker = new Worker(t());
        worker.onmessage = (e) => {
            const data = e.data;
            const {
                id
            } = data;
            this.snapshotInProgressMap.set(id, false);
            if (!('base64' in data))
                return;
            const {
                base64,
                type,
                width,
                height
            } = data;
            this.mutationCb({
                id,
                type: CanvasContext['2D'],
                commands: [{
                        property: 'clearRect',
                        args: [0, 0, width, height],
                    },
                    {
                        property: 'drawImage',
                        args: [{
                                rr_type: 'ImageBitmap',
                                args: [{
                                    rr_type: 'Blob',
                                    data: [{
                                        rr_type: 'ArrayBuffer',
                                        base64
                                    }],
                                    type,
                                }, ],
                            },
                            0,
                            0,
                            width,
                            height,
                        ],
                    },
                ],
            });
        };
        return worker;
    }
    initCanvasFPSObserver(fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options) {
        const rafId = this.takeSnapshot(false, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, options.dataURLOptions);
        this.restoreHandlers.push(() => {
            cancelAnimationFrame(rafId);
        });
    }
    initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {
        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, false);
        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector);
        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, unblockSelector, this.mirror);
        this.restoreHandlers.push(() => {
            canvasContextReset();
            canvas2DReset();
            canvasWebGL1and2Reset();
        });
    }
    snapshot(canvasElement) {
        const {
            options
        } = this;
        const rafId = this.takeSnapshot(true, options.sampling === 'all' ? 2 : options.sampling || 2, options.blockClass, options.blockSelector, options.unblockSelector, options.maxCanvasSize, options.dataURLOptions, canvasElement);
        this.restoreHandlers.push(() => {
            cancelAnimationFrame(rafId);
        });
    }
    takeSnapshot(isManualSnapshot, fps, blockClass, blockSelector, unblockSelector, maxCanvasSize, dataURLOptions, canvasElement) {
        const timeBetweenSnapshots = 1000 / fps;
        let lastSnapshotTime = 0;
        let rafId;
        const getCanvas = (canvasElement) => {
            if (canvasElement) {
                return [canvasElement];
            }
            const matchedCanvas = [];
            const searchCanvas = (root) => {
                root.querySelectorAll('canvas').forEach((canvas) => {
                    if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {
                        matchedCanvas.push(canvas);
                    }
                });
            };
            for (const item of this.windows) {
                const window = item.deref();
                if (window) {
                    searchCanvas(window.document);
                }
            }
            for (const item of this.shadowDoms) {
                const shadowRoot = item.deref();
                if (shadowRoot) {
                    searchCanvas(shadowRoot);
                }
            }
            return matchedCanvas;
        };
        const takeCanvasSnapshots = (timestamp) => {
            if (!this.windows.length) {
                return;
            }
            if (lastSnapshotTime &&
                timestamp - lastSnapshotTime < timeBetweenSnapshots) {
                rafId = onRequestAnimationFrame(takeCanvasSnapshots);
                return;
            }
            lastSnapshotTime = timestamp;
            getCanvas(canvasElement).forEach((canvas) => {
                if (!this.mirror.hasNode(canvas)) {
                    return;
                }
                const id = this.mirror.getId(canvas);
                if (this.snapshotInProgressMap.get(id))
                    return;
                if (!canvas.width || !canvas.height)
                    return;
                this.snapshotInProgressMap.set(id, true);
                if (!isManualSnapshot && ['webgl', 'webgl2'].includes(canvas.__context)) {
                    const context = canvas.getContext(canvas.__context);
                    if (context ? .getContextAttributes() ? .preserveDrawingBuffer === false) {
                        context.clear(context.COLOR_BUFFER_BIT);
                    }
                }
                createImageBitmap(canvas)
                    .then((bitmap) => {
                        this.worker ? .postMessage({
                            id,
                            bitmap,
                            width: canvas.width,
                            height: canvas.height,
                            dataURLOptions,
                            maxCanvasSize,
                        }, [bitmap]);
                    })
                    .catch((error) => {
                        callbackWrapper(() => {
                            throw error;
                        })();
                    });
            });
            if (!isManualSnapshot) {
                rafId = onRequestAnimationFrame(takeCanvasSnapshots);
            }
        };
        rafId = onRequestAnimationFrame(takeCanvasSnapshots);
        return rafId;
    }
    startPendingCanvasMutationFlusher() {
        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());
    }
    startRAFTimestamping() {
        const setLatestRAFTimestamp = (timestamp) => {
            this.rafStamps.latestId = timestamp;
            onRequestAnimationFrame(setLatestRAFTimestamp);
        };
        onRequestAnimationFrame(setLatestRAFTimestamp);
    }
    flushPendingCanvasMutations() {
        this.pendingCanvasMutations.forEach((values, canvas) => {
            const id = this.mirror.getId(canvas);
            this.flushPendingCanvasMutationFor(canvas, id);
        });
        onRequestAnimationFrame(() => this.flushPendingCanvasMutations());
    }
    flushPendingCanvasMutationFor(canvas, id) {
        if (this.frozen || this.locked) {
            return;
        }
        const valuesWithType = this.pendingCanvasMutations.get(canvas);
        if (!valuesWithType || id === -1)
            return;
        const values = valuesWithType.map((value) => {
            const {
                type,
                ...rest
            } = value;
            return rest;
        });
        const {
            type
        } = valuesWithType[0];
        this.mutationCb({
            id,
            type,
            commands: values
        });
        this.pendingCanvasMutations.delete(canvas);
    }
}

export {
    CanvasManager,
    CanvasManagerNoop
};